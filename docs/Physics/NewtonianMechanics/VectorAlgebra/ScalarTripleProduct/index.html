<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scalar Triple Product - Physics</title>
  <script type="text/javascript" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <style>
    body {
      font-family: Georgia, serif;
      max-width: 800px;
      margin: auto;
      padding: 2rem;
      background-color: #fcfcfc;
      color: #333;
    }
    h1, h2 {
      color: #003366;
    }
    pre {
      background-color: #f0f0f0;
      padding: 1rem;
      border-left: 5px solid #003366;
      overflow-x: auto;
    }
    .equation {
      font-family: 'Courier New', monospace;
      background: #f9f9f9;
      display: block;
      padding: 0.5rem;
      margin: 1rem 0;
      border-left: 3px solid #999;
    }
  </style>
</head>
<body>
  <h1>Scalar Triple Product</h1>

  <h2>1. Definition</h2>
  <p>The scalar triple product of three vectors \( \vec{A}, \vec{B}, \vec{C} \) is defined as:</p>
  <div class="equation">
    $$ \vec{A} \cdot (\vec{B} \times \vec{C}) $$
  </div>
  <p>This expression represents a scalar quantity, not a vector.</p>

  <h2>2. Geometric Interpretation</h2>
  <p>The scalar triple product gives the volume of a parallelepiped formed by the vectors \( \vec{A}, \vec{B}, \vec{C} \).</p>
  <p>If the vectors are placed tail-to-tail, they define a three-dimensional figure whose volume is:</p>
  <div class="equation">
    $$ V = |\vec{A} \cdot (\vec{B} \times \vec{C})| $$
  </div>
  <p>The absolute value is used because volume is always positive, regardless of vector orientation.</p>

  <h2>3. Example: Volume of a Parallelepiped</h2>
  <p>Let:</p>
  <div class="equation">
    $$ \vec{A} = \langle 1, 2, 3 \rangle,\quad \vec{B} = \langle 4, 5, 6 \rangle,\quad \vec{C} = \langle 7, 8, 9 \rangle $$
  </div>
  <p>Step 1: Compute \( \vec{B} \times \vec{C} \):</p>
  <div class="equation">
   $$ \begin{vmatrix}
    \hat{i} & \hat{j} & \hat{k} \\
    4 & 5 & 6 \\
    7 & 8 & 9
    \end{vmatrix} = \hat{i}(5 \cdot 9 - 6 \cdot 8) - \hat{j}(4 \cdot 9 - 6 \cdot 7) + \hat{k}(4 \cdot 8 - 5 \cdot 7) 
    $$
  </div>
  <div class="equation">
   $$ = \hat{i}(-3) - \hat{j}(-6) + \hat{k}(-3) = \langle -3, 6, -3 \rangle
   $$
  </div>

  <p>Step 2: Compute \( \vec{A} \cdot (\vec{B} \times \vec{C}) \):</p>
  <div class="equation">
    $$ \vec{A} \cdot (\vec{B} \times \vec{C}) = 1(-3) + 2(6) + 3(-3) = -3 + 12 - 9 = 0
    $$
  </div>
  <p><strong>Result:</strong> The scalar triple product is 0, which implies that the vectors are coplanar.</p>

  <h2>4. Cyclic Property</h2>
  <p>The scalar triple product is invariant under a cyclic permutation:</p>
  <div class="equation">
    $$ \vec{A} \cdot (\vec{B} \times \vec{C}) = \vec{B} \cdot (\vec{C} \times \vec{A}) = \vec{C} \cdot (\vec{A} \times \vec{B}) $$
  </div>

  <h2>5. Non-Commutativity</h2>
  <p>The scalar triple product is not commutative. Swapping the order of vectors may change the sign:</p>
  <div class="equation">
    $$ \vec{A} \cdot (\vec{B} \times \vec{C}) = -\vec{A} \cdot (\vec{C} \times \vec{B}) $$
  </div>

  <h2>6. Linear Dependence of Vectors</h2>
  <p>If the scalar triple product is zero, it implies that the three vectors are linearly dependent (they lie in the same plane):</p>
  <div class="equation">
    $$ \vec{A} \cdot (\vec{B} \times \vec{C}) = 0 \Rightarrow \text{Vectors are coplanar} $$
  </div>

  <h2>7. More Examples</h2>

  <h3>Example 1:</h3>
  <p>\( \vec{A} = \langle 2, 0, 1 \rangle, \vec{B} = \langle 1, -1, 2 \rangle, \vec{C} = \langle 3, 2, 1 \rangle \)</p>
  <p>Step 1: \( \vec{B} \times \vec{C} \)</p>
  <div class="equation">
   $$ \begin{vmatrix}
    \hat{i} & \hat{j} & \hat{k} \\
    1 & -1 & 2 \\
    3 & 2 & 1
    \end{vmatrix} = \hat{i}((-1)(1) - 2(2)) - \hat{j}(1(1) - 2(3)) + \hat{k}(1(2) - (-1)(3))

    $$
  </div>
  <div class="equation">
    $$
     = \hat{i}(-1 - 4) - \hat{j}(1 - 6) + \hat{k}(2 + 3) = \langle -5, 5, 5 \rangle

    $$
  </div>
  <p>Step 2: Dot with \( \vec{A} \):</p>
  <div class="equation">
   $$
    2(-5) + 0(5) + 1(5) = -10 + 0 + 5 = -5

    $$
  </div>
  <p><strong>Volume =</strong> \( |-5| = 5 \)</p>

  <h3>Example 2 (Coplanar Vectors):</h3>
  <p>\( \vec{A} = \langle 1, 2, 3 \rangle, \vec{B} = \langle 2, 4, 6 \rangle, \vec{C} = \langle 3, 6, 9 \rangle \)</p>
  <p>Note that \( \vec{B} = 2\vec{A} \), \( \vec{C} = 3\vec{A} \), so they are all parallel.</p>
  <p>Step 1: \( \vec{B} \times \vec{C} = \vec{0} \)</p>
  <div class="equation">
   $$ 
   
   \vec{A} \cdot (\vec{0}) = 0

   $$
  </div>
  <p><strong>Result:</strong> Volume = 0</p>
  <>
    <h2>Animation</h2>
    <pre>
      <code>
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.widgets import Slider
from mpl_toolkits.mplot3d.art3d import Poly3DCollection  # Add this import

# Function to compute the scalar triple product
def scalar_triple_product(A, B, C):
    return np.dot(A, np.cross(B, C))

# Initialize vectors
A = np.array([1, 2, 3])
B = np.array([4, 5, 6])
C = np.array([7, 8, 9])

# Create the figure and 3D axis
fig = plt.figure(figsize=(12, 10))  # Adjust figure size
ax = fig.add_subplot(111, projection='3d')

# Function to plot vectors and parallelepiped
def plot_vectors(ax, A, B, C):
    ax.quiver(0, 0, 0, A[0], A[1], A[2], color='r', label='A', linewidth=2)
    ax.quiver(0, 0, 0, B[0], B[1], B[2], color='g', label='B', linewidth=2)
    ax.quiver(0, 0, 0, C[0], C[1], C[2], color='b', label='C', linewidth=2)

    # Parallelepiped faces using Poly3DCollection
    vertices = np.array([[0, 0, 0], A, B, C, A + B, A + C, B + C, A + B + C])
    faces = [
        [vertices[0], vertices[1], vertices[4], vertices[2]],  # ABC plane
        [vertices[0], vertices[1], vertices[5], vertices[3]],  # AB plane
        [vertices[0], vertices[2], vertices[3], vertices[6]],  # AC plane
        [vertices[0], vertices[3], vertices[5], vertices[6]],  # BC plane
        [vertices[1], vertices[4], vertices[7], vertices[5]],  # A + B plane
        [vertices[2], vertices[3], vertices[7], vertices[6]],  # A + C plane
    ]
    ax.add_collection3d(Poly3DCollection(faces, facecolors='cyan', linewidths=1, edgecolors='r', alpha=0.3))

    ax.set_xlim([0, 10])
    ax.set_ylim([0, 10])
    ax.set_zlim([0, 10])
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.legend()

# Update function for the animation
def update(val):
    global A, B, C

    # Update vector components from sliders
    A = np.array([slider_Ax.val, slider_Ay.val, slider_Az.val])
    B = np.array([slider_Bx.val, slider_By.val, slider_Bz.val])
    C = np.array([slider_Cx.val, slider_Cy.val, slider_Cz.val])

    # Clear previous plot and plot new vectors
    ax.clear()
    plot_vectors(ax, A, B, C)

    # Compute scalar triple product
    volume = scalar_triple_product(A, B, C)
    
    # Update scalar triple product display
    ax.text2D(0.05, 0.95, f'Scalar Triple Product: {volume:.2f}', transform=ax.transAxes, fontsize=14, color='black')

    # Redraw the figure
    fig.canvas.draw_idle()

# Create sliders for interactive vector components
ax_slider_Ax = plt.axes([0.2, 0.02, 0.65, 0.03], facecolor='lightgoldenrodyellow')
ax_slider_Ay = plt.axes([0.2, 0.06, 0.65, 0.03], facecolor='lightgoldenrodyellow')
ax_slider_Az = plt.axes([0.2, 0.1, 0.65, 0.03], facecolor='lightgoldenrodyellow')

ax_slider_Bx = plt.axes([0.2, 0.14, 0.65, 0.03], facecolor='lightgoldenrodyellow')
ax_slider_By = plt.axes([0.2, 0.18, 0.65, 0.03], facecolor='lightgoldenrodyellow')
ax_slider_Bz = plt.axes([0.2, 0.22, 0.65, 0.03], facecolor='lightgoldenrodyellow')

ax_slider_Cx = plt.axes([0.2, 0.26, 0.65, 0.03], facecolor='lightgoldenrodyellow')
ax_slider_Cy = plt.axes([0.2, 0.3, 0.65, 0.03], facecolor='lightgoldenrodyellow')
ax_slider_Cz = plt.axes([0.2, 0.34, 0.65, 0.03], facecolor='lightgoldenrodyellow')

# Sliders for vector components
slider_Ax = Slider(ax_slider_Ax, 'Ax', -10, 10, valinit=A[0], valstep=0.1)
slider_Ay = Slider(ax_slider_Ay, 'Ay', -10, 10, valinit=A[1], valstep=0.1)
slider_Az = Slider(ax_slider_Az, 'Az', -10, 10, valinit=A[2], valstep=0.1)

slider_Bx = Slider(ax_slider_Bx, 'Bx', -10, 10, valinit=B[0], valstep=0.1)
slider_By = Slider(ax_slider_By, 'By', -10, 10, valinit=B[1], valstep=0.1)
slider_Bz = Slider(ax_slider_Bz, 'Bz', -10, 10, valinit=B[2], valstep=0.1)

slider_Cx = Slider(ax_slider_Cx, 'Cx', -10, 10, valinit=C[0], valstep=0.1)
slider_Cy = Slider(ax_slider_Cy, 'Cy', -10, 10, valinit=C[1], valstep=0.1)
slider_Cz = Slider(ax_slider_Cz, 'Cz', -10, 10, valinit=C[2], valstep=0.1)

# Link sliders to update function
slider_Ax.on_changed(update)
slider_Ay.on_changed(update)
slider_Az.on_changed(update)

slider_Bx.on_changed(update)
slider_By.on_changed(update)
slider_Bz.on_changed(update)

slider_Cx.on_changed(update)
slider_Cy.on_changed(update)
slider_Cz.on_changed(update)

# Adjust layout to ensure sliders are below the 3D plot
plt.subplots_adjust(bottom=0.4)  # Adjust bottom margin to create space for sliders

# Initial plot setup
plot_vectors(ax, A, B, C)
plt.show()

      </code>
    </pre>
  </p>
  <footer>
    <p><a href="../index.html">&#8592; Back to Home</a></p>
  </footer>
</body>
</html>