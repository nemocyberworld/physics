<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orthogonal and Orthonormal Vectors - Lesson</title>
  <script type="text/javascript" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <style>
    body {
      font-family: Georgia, serif;
      max-width: 800px;
      margin: auto;
      padding: 2rem;
      background-color: #fcfcfc;
      color: #333;
    }
    h1, h2, h3 {
      color: #003366;
    }
    pre {
      background-color: #f0f0f0;
      padding: 1rem;
      border-left: 5px solid #003366;
      overflow-x: auto;
    }
    .equation {
      font-family: 'Courier New', monospace;
      background: #f9f9f9;
      display: block;
      padding: 0.5rem;
      margin: 1rem 0;
      border-left: 3px solid #999;
    }
  </style>
</head>
<body>
  <h1>Orthogonal and Orthonormal Vectors</h1>

  <h2>1. Introduction</h2>
  <p>Vectors are a foundational concept in physics and mathematics. In particular, the ideas of orthogonal and orthonormal vectors are crucial when analyzing spaces, performing computations, and simplifying complex systems in fields like physics, engineering, and computer science.</p>

  <h2>2. What Are Orthogonal Vectors?</h2>
  <p>Two vectors are said to be <strong>orthogonal</strong> if they are at a right angle (90 degrees) to each other. In mathematical terms, this means their dot product is zero.</p>
  <div class="equation">
    $$ \vec{a} \cdot \vec{b} = 0 $$
  </div>
  <p>This condition implies that there is no overlap in direction between the two vectors — they are completely independent in space.</p>

  <h3>Example</h3>
  <p>Let \( \vec{a} = [1, 0] \) and \( \vec{b} = [0, 1] \). Then,</p>
  <div class="equation">
    $$ \vec{a} \cdot \vec{b} = 1 \times 0 + 0 \times 1 = 0 $$
  </div>
  <p>So, these vectors are orthogonal.</p>

  <h2>3. What Are Orthonormal Vectors?</h2>
  <p>Vectors are <strong>orthonormal</strong> if they are both orthogonal and each has a length (magnitude) of 1.</p>
  <div class="equation">
    \[ \|\vec{a}\| = \|\vec{b}\| = 1 \quad \text{and} \quad \vec{a} \cdot \vec{b} = 0 \]
  </div>
  <p>Orthonormal vectors are especially useful in defining coordinate systems and simplifying matrix operations.</p>

  <h3>Example</h3>
  <p>Let \( \vec{a} = [1, 0] \) and \( \vec{b} = [0, 1] \) again. Their magnitudes are:</p>
  <div class="equation">
    $$ \|\vec{a}\| = \sqrt{1^2 + 0^2} = 1, \quad \|\vec{b}\| = \sqrt{0^2 + 1^2} = 1 $$
  </div>
  <p>Since they are orthogonal and both have magnitude 1, they are orthonormal.</p>

  <h2>4. Real-World Applications</h2>

  <h3>Computer Graphics</h3>
  <p>Orthonormal vectors are used in rendering 3D graphics. Camera orientation, lighting, and object rotations often rely on orthonormal basis vectors.</p>

  <h3>Robotics</h3>
  <p>In robotics, movements and positions are described in orthonormal coordinate frames, which makes calculations simpler and more reliable.</p>

  <h3>Signal Processing</h3>
  <p>Fourier series and transforms use orthogonal basis functions to decompose signals into simpler components.</p>

  <h3>Physics</h3>
  <p>Coordinate systems in physics are usually defined using orthonormal vectors to simplify equations of motion and field equations.</p>

  <h2>5. Visualization</h2>
  <p>Imagine the x, y, and z axes in a 3D coordinate system. Each axis is orthogonal to the others, and if each axis vector is of length 1, they are orthonormal.</p>

  <h2>6. Python Example</h2>
  <pre><code>import numpy as np
import matplotlib.pyplot as plt

# Define vectors
a = np.array([1, 0])
b = np.array([0, 1])
c = np.array([1, 1])

# Check orthogonality
print("Dot product of a and b:", np.dot(a, b))
print("Norm of a:", np.linalg.norm(a))
print("Norm of b:", np.linalg.norm(b))

# Plotting
plt.figure(figsize=(6,6))
plt.quiver(0, 0, a[0], a[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector a')
plt.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='red', label='Vector b')
plt.quiver(0, 0, c[0], c[1], angles='xy', scale_units='xy', scale=1, color='green', label='Vector c')

plt.xlim(-1, 2)
plt.ylim(-1, 2)
plt.axhline(0, color='gray', linewidth=0.5)
plt.axvline(0, color='gray', linewidth=0.5)
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.legend()
plt.title('Visualizing Orthogonal and Non-Orthogonal Vectors')
plt.show()</code></pre>

  <h2>7. Summary</h2>
  <ul>
    <li><strong>Orthogonal vectors:</strong> Dot product is 0.</li>
    <li><strong>Orthonormal vectors:</strong> Orthogonal and unit length.</li>
    <li>Widely used in physics, graphics, robotics, and data analysis.</li>
  </ul>

  <h2>11. Interactive Draggable Vectors</h2>

<div style="margin-bottom: 1rem;">
  <strong>Vector a:</strong>
  x: <input type="number" id="ax" value="1" step="0.1" disabled>
  y: <input type="number" id="ay" value="0" step="0.1" disabled>
  &nbsp;&nbsp;<br>
  <strong>Vector b:</strong>
  x: <input type="number" id="bx" value="0" step="0.1" disabled>
  y: <input type="number" id="by" value="1" step="0.1" disabled>
</div>

<canvas id="vectorCanvas" width="400" height="400" style="border:1px solid #ccc; background-color: #f9f9f9;"></canvas>

<div id="output" style="margin-top: 1rem; font-family: monospace; background: #eef6fb; padding: 1rem; border-left: 4px solid #006699;"></div>

<script>
  const canvas = document.getElementById('vectorCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  const originX = width / 2;
  const originY = height / 2;
  const scale = 80;

  let a = { x: 1, y: 0 };
  let b = { x: 0, y: 1 };
  let isDragging = false;
  let draggingVector = null;
  let offsetX = 0;
  let offsetY = 0;

  const axInput = document.getElementById("ax");
  const ayInput = document.getElementById("ay");
  const bxInput = document.getElementById("bx");
  const byInput = document.getElementById("by");
  const outputDiv = document.getElementById("output");

  function drawAxes() {
    ctx.strokeStyle = 'gray';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, originY);
    ctx.lineTo(width, originY);
    ctx.moveTo(originX, 0);
    ctx.lineTo(originX, height);
    ctx.stroke();
  }

  function drawVector(v, color, label) {
    const endX = originX + v.x * scale;
    const endY = originY - v.y * scale;

    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(originX, originY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // Arrowhead
    const headlen = 10;
    const angle = Math.atan2(originY - endY, endX - originX);
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY + headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY + headlen * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(endX, endY);
    ctx.fill();

    ctx.font = "14px Arial";
    ctx.fillText(label, endX + 5, endY - 5);
  }

  function dot(a, b) {
    return a.x * b.x + a.y * b.y;
  }

  function norm(v) {
    return Math.sqrt(v.x ** 2 + v.y ** 2);
  }

  function angleBetween(a, b) {
    const cosTheta = dot(a, b) / (norm(a) * norm(b));
    return Math.acos(Math.min(Math.max(cosTheta, -1), 1)) * 180 / Math.PI;
  }

  function update() {
    // Update input fields
    axInput.value = a.x;
    ayInput.value = a.y;
    bxInput.value = b.x;
    byInput.value = b.y;

    // Update the canvas
    ctx.clearRect(0, 0, width, height);
    drawAxes();
    drawVector(a, 'blue', 'a');
    drawVector(b, 'red', 'b');
    drawVector({ x: a.x + b.x, y: a.y + b.y }, 'green', 'c');

    // Update output
    outputDiv.innerHTML = `
      Dot(a, b): ${dot(a, b).toFixed(2)}<br>
      ||a||: ${norm(a).toFixed(2)}  ||b||: ${norm(b).toFixed(2)}<br>
      Angle between a and b: ${angleBetween(a, b).toFixed(2)}°
    `;
  }

  // Mouse events for dragging vectors
  canvas.addEventListener("mousedown", function(e) {
    const mouseX = e.offsetX;
    const mouseY = e.offsetY;

    // Check if the mouse is near any vector's endpoint
    if (Math.abs(mouseX - (originX + a.x * scale)) < 10 && Math.abs(mouseY - (originY - a.y * scale)) < 10) {
      isDragging = true;
      draggingVector = 'a';
      offsetX = mouseX - (originX + a.x * scale);
      offsetY = mouseY - (originY - a.y * scale);
    } else if (Math.abs(mouseX - (originX + b.x * scale)) < 10 && Math.abs(mouseY - (originY - b.y * scale)) < 10) {
      isDragging = true;
      draggingVector = 'b';
      offsetX = mouseX - (originX + b.x * scale);
      offsetY = mouseY - (originY - b.y * scale);
    }
  });

  canvas.addEventListener("mousemove", function(e) {
    if (isDragging) {
      const mouseX = e.offsetX;
      const mouseY = e.offsetY;

      if (draggingVector === 'a') {
        a.x = (mouseX - offsetX - originX) / scale;
        a.y = (originY - mouseY - offsetY) / scale;
      } else if (draggingVector === 'b') {
        b.x = (mouseX - offsetX - originX) / scale;
        b.y = (originY - mouseY - offsetY) / scale;
      }

      update();
    }
  });

  canvas.addEventListener("mouseup", function() {
    isDragging = false;
    draggingVector = null;
  });

  update(); // Initial render
</script>

  <footer>
    <p><a href="../index.html">← Back to Home</a></p>
  </footer>
</body>
</html>
